#!/usr/bin/python
####################################
#This program takes an BIP38 private key and password
#then generates a decrypted private key and Bitcoin Address

import hashlib, binascii # local imports required for conversions, they are standard with Python
import pybip38

Pcurve = 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 -1 # The proven prime
N=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 # Number of points in the field
Acurve = 0; Bcurve = 7 # These two defines the elliptic curve. y^2 = x^3 + Acurve * x + Bcurve
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240  #x coordinate of GPoint
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424  #y coordinate of GPoint
GPoint = (Gx,Gy) # This is our generator point. Trillions of dif ones possible
t='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' # Base58 Charset

def Byte2Hex(b): #Convert a byte string to hex number
    out="";
    for x in b:
        y=hex(ord(x))[2:]
        if len(y)==1:
            y="0"+y
        out+="%2s"%y    
    return out

def Hex2Byte(hexStr): # convert hex number into a byte string
    bytes = []
    hexStr = ''.join( hexStr.split(" ") )
    for i in range(0, len(hexStr), 2):
        bytes.append( chr( int (hexStr[i:i+2], 16 ) ) )
    return ''.join( bytes )

def Int2Byte(n,b):    #Convert a integer to a byte string of length b
    out=""    
    for i in range(b):
        (n,m)=divmod(n,256)
        out=chr(m)+out    
    return out

def modinv(a,n=Pcurve): #Extended Euclidean Algorithm/'division' in elliptic curves
    lm, hm = 1,0
    low, high = a%n,n
    while low > 1:
        ratio = high/low
        nm, new = hm-lm*ratio, high-low*ratio
        lm, low, hm, high = nm, new, lm, low
    return lm % n

def ECadd(a,b): # Not true addition, invented for EC. Could have been called anything.
    LamAdd = ((b[1]-a[1]) * modinv(b[0]-a[0],Pcurve)) % Pcurve
    x = (LamAdd*LamAdd-a[0]-b[0]) % Pcurve
    y = (LamAdd*(a[0]-x)-a[1]) % Pcurve
    return (x,y)

def ECdouble(a): # This is called point doubling, also invented for EC.
    Lam = ((3*a[0]*a[0]+Acurve) * modinv((2*a[1]),Pcurve)) % Pcurve
    x = (Lam*Lam-2*a[0]) % Pcurve
    y = (Lam*(a[0]-x)-a[1]) % Pcurve
    return (x,y)

def EccMultiply(GenPoint,ScalarHex): #Double & add. Not true multiplication
    if ScalarHex == 0 or ScalarHex >= N: raise Exception("Invalid Scalar/Private Key")
    ScalarBin = str(bin(ScalarHex))[2:]
    Q=GenPoint
    for i in range (1, len(ScalarBin)): # This is invented EC multiplication.
        Q=ECdouble(Q); # print "DUB", Q[0]; print
        if ScalarBin[i] == "1":
            Q=ECadd(Q,GenPoint); # print "ADD", Q[0]; print
    return (Q)

def numtowif(numpriv): #converts numerical private key to WIF
 step1 = '80'+hex(numpriv)[2:].strip('L').zfill(64)
 step2 = hashlib.sha256(binascii.unhexlify(step1)).hexdigest()
 step3 = hashlib.sha256(binascii.unhexlify(step2)).hexdigest()
 step4 = int(step1 + step3[:8] , 16)
 return ''.join([t[step4/(58**l)%58] for l in range(100)])[::-1].lstrip('1')

def wiftonum(wifpriv):    #converts from WIF to numerical private key
 return sum([t.index(wifpriv[::-1][l])*(58**l) for l in range(len(wifpriv))])/(2**32)%(2**256)

def validwif(wifpriv):    #validates WIF generated by converting it back and forth
 return numtowif(wiftonum(wifpriv))==wifpriv

def b58encode(v):    #Encode a byte string to the Base58
    base=len(t)
    val=0    
    for c in v:
        val*=256
        val+=ord(c)
    result=""
    while val:
        (val,mod)=divmod(val,base)
        result=t[mod]+result
    pad=0
    for c in v:
        if c=="\0":
            pad+=1
        else:
            break
    return (t[0]*pad)+result

def pubtoaddy(puk): #converts uncompressed public key to public address
    version=chr(0)      
    h=hashlib.new("SHA256")
    h.update(puk)    
    s=h.digest()
    h=hashlib.new("RIPEMD160")
    h.update(s)
    kh=version+h.digest()
    h=hashlib.new("SHA256")
    h.update(kh)
    cs=h.digest()
    h=hashlib.new("SHA256")
    h.update(cs)
    cs=h.digest()[:4]
    adr=b58encode(kh+cs)
    return adr

if __name__ == "__main__":
    bip38=raw_input('Enter BIP38 Private Key: ')
    passwd=raw_input('Enter Password: ')
    pk=pybip38.bip38decrypt(passwd, bip38)
    privKey=wiftonum(pk)
    print('Bitcoin Private Key (WIF): %s' % numtowif(privKey))
    PublicKey = EccMultiply(GPoint,privKey)
    ucpuk = "04" + "%064x" % PublicKey[0] + "%064x" % PublicKey[1]
    PubAd = pubtoaddy(Hex2Byte(ucpuk)) 
    print('Bitcoin Address: %s' % PubAd)
